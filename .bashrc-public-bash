#!/bin/bash

qcd()
{
    local branch=$(git symbolic-ref HEAD)
    branch=${branch#refs/heads/}
    
    cd .git/patches/$branch
}

lcd()
{
    if test $# != 1; then
        return 1
    elif test "$1" = -; then
        cd_ok -
        return 0
    elif test "$1" = .beagrep; then
        cd_beagrep;
        return 0;
    fi
    

    if [[ "$1" =~ ^\\\\|^//|^smb://|/smb/ && `uname` = Linux ]]; then
        chmod 600 ~/.smb/*
        if ! mount | grep -q '^smbnetfs on'; then
            if smbnetfs -o allow_root ~/smb 2>&1|grep -v "mountpoint is not empty\|'nonempty' mount option\|gnome-keyring is not available"|grep -q . ; then
                sudo umount -l ~/smb
                smbnetfs -o allow_root ~/smb 2>&1|grep -v "mountpoint is not empty\|'nonempty' mount option\|gnome-keyring is not available"
            fi
        fi
        builtin cd ~/smb/"$(ip-or-name "$1")"
        return 0
    fi
   
    local ori=$1
    local start=$PWD
    local looking=$PWD
    local x=0
    while ! test -e "$1" >/dev/null || { [[ "$looking" =~ ^$HOME/smb(/[^/]+)?$ ]] && test "$looking" != "$start"; }; do # [[..]] because test -e not work in smbnetfs top levels
        set -- ../"$1";
        looking=`dirname "$looking"`
        test "$looking" = / && break
        if test -e "$looking"/"$ori"; then
            if test -d "$looking"/"$ori"; then
                builtin cd "$looking"/"$ori"
            else
                builtin cd "$(dirname "$looking"/"$ori")"
            fi
            return $?
        fi
    done

    if ! test -e "$1" >/dev/null; then
        _ucd $ori
        return $?
    fi

    link=$1
    if test -f "$link" && echo "${link##*.}"|grep -i '^lnk$' -q; then 
            link=`readshortcut "$link"`
    fi
    if test -d "$link"; then
        if test "$link" = "`pwd`"; then
            return 1;
        fi
        builtin cd "$link"
        return $?
    elif test -L "$link" -a -f "$link"; then
        builtin cd "$(dirname "$(readlink -f "$link")")"
        return $?
    else
        builtin cd "$(dirname "$link")"
        return $?
    fi
}

_ucd() #we go to upper dir which match the $1, for ex, cd 'ho' in /home/bhj will go to /home, 
{
    local x=0
    dir=`dirname "$(pwd)"`
    dir_basename=`basename "$dir"`
    while ! echo $dir_basename|grep -e $1 -i -q && ((x++ < 10)); do
        dir=`dirname "$dir"`
        dir_basename=`basename "$dir"`
	if test x"$dir" = x/; then
	    break
	fi
    done
    if test x"$dir" = x/; then #obviously, we very not likely want to go to / with this complex setup
        return 1;
    fi
    builtin cd "$dir"
    return $?
}

svn-info-clip()
{
    svn info "$1" |grep '^URL:'|sed -e 's/^URL: //; s/^https/http/'|tr -d '\r\n' | putclip
}

alias for-code-reading='for-code-reading -i -v'

function hir() {
    if test $# = 0; then
	history -r
	backup_bash_history
        echo "~/.bash_history.bak has $(wc -l ~/.bash_history.bak|pn 1) lines"
	cat ~/.where.bak >> ~/.where
    else
	command hil "$@"
    fi
}

function _select_cd() {

    local IFS=$'\n'
    local dirs=( 
	"$@"
    )

    if test ${#dirs[@]} = 0; then
        echo 'Error: no such file or directory'
        return 1
    elif test ${#dirs[@]} = 1; then
        builtin cd ${dirs[0]}
    else 
        NUM=`my_select "${dirs[@]}"`
        ((NUM--))
        builtin cd "${dirs[$NUM]}"
    fi
}

function tcd() {
    local IFS=$'\n'

    _select_cd $(
	export LOOKUP_NON_EXIST_FILES=false 
	lookup_file $(today "$@" | perl -npe 's/(.*)-.*/$1/')
	lookup_file `today-- "$@"`
    ) $(
	export LOOKUP_NON_EXIST_FILES=false
	pcd ~/today && {
	    lookup_file $(today "$@" | perl -npe 's/(.*)-.*/$1/')
	    lookup_file `today-- "$@"`; 
	}
    )
}

function mcd() {
    local IFS=$'\n'
    _select_cd $(lookup_file "$@")
}

alias hil=hir

cd_record()
{
    local ret=$?
    if test $ret -ne 0; then
        export PROMPT_RET="Ret: $ret @ $(date +%H:%M:%S) "
    else
        export PROMPT_RET=
    fi
    history -a
    if test "$BHJ_PWD" = "$PWD"; then
	return $ret
    fi
    BHJ_PWD=$PWD

   (
       if test "$LC_ALL" != C -a "$has_python3"; then
	   where; 
       fi&
   )
   return $ret
}

start_recursive_shell()
{
    (
        export RECURSIVE_SHELL='[01;32mRecursive[01;31m:[01;32m'"$@"'[01;34m '
        bash
    )
}

export -f start_recursive_shell
alias start-recursive-shell=start_recursive_shell

if which -s python3; then
    has_python3=true
else
    has_python3=
fi

export PROMPT_COMMAND="cd_record"
if test -n "$has_python3"; then
    alias cd=cd_bhj
fi
alias cow='cp --reflink=always -a'
shopt -s nocaseglob
shopt -s histappend
