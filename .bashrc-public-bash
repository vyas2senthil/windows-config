#!/bin/bash

lcd()
{
    if test $# != 1; then
        return 1
    elif test "$1" = -; then
        cd_ok -
        return 0
    elif test "$1" = .beagrep; then
        cd_beagrep;
        return 0;
    fi
    

    if [[ "$1" =~ ^\\\\|^//|^smb://|/smb/ && `uname` = Linux ]]; then
        chmod 600 ~/.smb/*
	if ! mount | grep -q '^smbnetfs on'; then
            if smbnetfs -o allow_root ~/smb 2>&1|grep -v "mountpoint is not empty\|'nonempty' mount option\|gnome-keyring is not available"|grep -q . ; then
		sudo umount -l ~/smb
		smbnetfs -o allow_root ~/smb 2>&1|grep -v "mountpoint is not empty\|'nonempty' mount option\|gnome-keyring is not available"
	    fi
	fi
        builtin cd ~/smb/"$(ip-or-name "$1")"
        return 0
    fi
   
    local ori=$1
    local start=$PWD
    local looking=$PWD
    local x=0
    while ! test -e "$1" >/dev/null || { [[ "$looking" =~ ^$HOME/smb(/[^/]+)?$ ]] && test "$looking" != "$start"; }; do # [[..]] because test -e not work in smbnetfs top levels
        set -- ../"$1";
	looking=`dirname "$looking"`
	test "$looking" = / && break
    done

    if ! test -e "$1" >/dev/null; then
        _ucd $ori
        return $?
    fi

    link=$1
    if test -f "$link" && echo "${link##*.}"|grep -i '^lnk$' -q; then 
            link=`readshortcut "$link"`
    fi
    if test -d "$link"; then
        if test "$link" = "`pwd`"; then
            return 1;
        fi
        builtin cd "$link"
        return $?
    elif test -L "$link" -a -f "$link"; then
        builtin cd "$(dirname "$(readlink -f "$link")")"
        return $?
    else
        builtin cd "$(dirname "$link")"
        return $?
    fi
}

_ucd() #we go to upper dir which match the $1, for ex, cd 'ho' in /home/bhj will go to /home, 
{
    local x=0
    dir=`dirname "$(pwd)"`
    dir_basename=`basename "$dir"`
    while ! echo $dir_basename|grep -e $1 -i -q && ((x++ < 10)); do
        dir=`dirname "$dir"`
        dir_basename=`basename "$dir"`
	if test x"$dir" = x/; then
	    break
	fi
    done
    if test x"$dir" = x/; then #obviously, we very not likely want to go to / with this complex setup
        return 1;
    fi
    builtin cd "$dir"
    return $?
}

svn-info-clip()
{
    svn info "$1" |grep '^URL:'|sed -e 's/^URL: //; s/^https/http/'|tr -d '\r\n' | putclip
}

alias for-code-reading='for-code-reading -i -v'

function hir() {
    if test $# = 0; then
	history -r
	backup_bash_history
	cat ~/.where.bak >> ~/.where
    else
	command hil "$@"
    fi
}

function _select_cd() {

    local IFS=$'\n'
    local dirs=( 
	"$@"
    )

    if test ${#dirs[@]} = 0; then
        echo 'Error: no such file or directory'
        return 1
    elif test ${#dirs[@]} = 1; then
        builtin cd ${dirs[0]}
    else 
        NUM=`my_select "${dirs[@]}"`
        ((NUM--))
        builtin cd "${dirs[$NUM]}"
    fi
}

function tcd() {
    local IFS=$'\n'

    _select_cd $(
	export LOOKUP_NON_EXIST_FILES=false 
	lookup_file $(today "$@" | perl -npe 's/(.*)-.*/$1/')
	lookup_file `today-- "$@"`
    ) $(
	export LOOKUP_NON_EXIST_FILES=false
	pcd ~/today && {
	    lookup_file $(today "$@" | perl -npe 's/(.*)-.*/$1/')
	    lookup_file `today-- "$@"`; 
	}
    )
}

function mcd() {
    local IFS=$'\n'
    _select_cd $(lookup_file "$@")
}

for x in ~/.bash_completion.d/*; do 
    . "$x"
done

alias hil=hir
