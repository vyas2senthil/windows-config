import Data.List
import Text.ParserCombinators.Parsec

----------------------------------------------------------------

threshold = 13 -- height of column

input    =    "firemacs.yml"
template =    "config.xul"
output1  = "../config-name.js"
output2  = "../keybinding.js"
output3  = "../config.xul"

header = "////////////////////////////////////////////////////////////////\n" ++
         "//\n" ++
         "// Automatically generated by Haskell with YML\n" ++
         "//\n" ++
         "\n"

----------------------------------------------------------------

main = do cs <- readFile input
          let lst = parseYml cs
          msg output1
          makeFile1 output1 lst
          done
          msg output2
          makeFile2 output2 lst
          done
          msg output3
          tmp <- readFile template
          makeFile3 output3 tmp lst
          done
    where
      msg file = putStr $ "Generating \"" ++ file ++ "\"... "
      done = putStrLn "done"

----------------------------------------------------------------

isBool tup = dtype tup == "boolean"
jsArray lst = (concat $ intersperse ",\n" lst) ++ "\n"

----------------------------------------------------------------

makeFile1 file lst = writeFile file $ makeContents1 lst

makeContents1 lst = header ++
                    "FmxConfig._names = [\n" ++
                    nonbool ++
                    "];\n" ++
                    "\n" ++
                    "FmxConfig._boolNames = [\n" ++
                    bool ++
                    "];\n"
    where
      addPrefix str = "  '" ++ str ++ "'"
      nonbool = jsArray $ map addPrefix $ map name $ filter (not.isBool) lst
      bool = jsArray $ map addPrefix $ map name $ filter isBool lst

----------------------------------------------------------------

makeFile2 file lst = writeFile file $ makeContents2 lst

keyGroup = ["View", "Edit", "Common", "Menu"]
allGroup  = ["Option"] ++ keyGroup

makeContents2 lst = header ++
                    "Firemacs.Commands = {};\n" ++
                    "\n" ++
                    (command keyGroup lst) ++
                    "Firemacs.CmdKey = {};\n" ++
                    "\n" ++
                    (cmdKey allGroup lst)

command keygroup lst = concatMap eachGroup keygroup
    where
      eachGroup gName = jsObj $ filter (\ent -> grp ent == gName) lst
          where
            jsObj l = "Firemacs.Commands." ++ gName ++ " = {\n" ++
                      (jsArray $ map jsFunc l) ++
                      "};\n" ++
                      "\n"
            jsFunc ent = "    " ++ (name ent) ++ ": function(e) {\n" ++
                         "        " ++ (body ent) ++ "\n" ++
                         "    }"

cmdKey allgroup lst = concatMap eachGroup allgroup
    where
      eachGroup gName = jsObj $ filter (\ent -> grp ent == gName) lst
          where
            jsObj l = "Firemacs.CmdKey." ++ gName ++ " = {\n" ++
                      (jsArray $ map jsHash l) ++
                      "};\n" ++
                      "\n"
            jsHash ent = "    " ++ (name ent) ++ ": " ++ (jsKey $ key ent)
            jsKey "true" = "true"
            jsKey "false" = "false"
            jsKey str = "'" ++ str ++ "'"

----------------------------------------------------------------

makeFile3 file tmp lst = writeFile file $ replace $ makeContents3 lst
    where
      replace r = unlines $ concat $ map repl $ lines tmp
          where
            repl "$tabpanels$" = lines r
            repl str = [str]


indentWith prefix str = unlines $ map spcs $ lines str
    where
      spcs str = prefix ++ str

indent = indentWith "  "

getOpts lot = concatMap keyval lot
    where
      keyval (k, v) = " " ++ k ++ "=\"" ++ (escape v) ++ "\""
      escape value = concatMap repl value
      repl '<' = "&lt;"
      repl '>' = "&gt;"
      repl c   = [c]

dtag name opts cont = open ++ (indent cont) ++ close
    where
      open  = "<" ++ name ++ (getOpts opts) ++ ">\n"
      close = "</" ++ name ++ ">\n"

stag name opts = "<" ++ name ++ (getOpts opts) ++ " />\n"

makeContents3 lst = tabpanels
    where
      tabpanels  = indentWith "    " $ concatMap tabpanel allGroup
      tabpanel g = dtag "tabpanel" [("equalsize","always")] $ grids g

      grids g = let ents = filter (\ent -> grp ent == g) lst
                in grid ents

      grid [] = ""
      grid ents = gridtag ++ loop
          where
            hd = take threshold ents
            tl = drop threshold ents
            gridtag = dtag "grid" [("flex","1")] (columns ++ rows hd)
            loop = grid tl

      columns = dtag "columns" [] (column ++ column)
      column = stag "column" []

      rows slst = dtag "rows" [] $ concatMap row slst
      row ent = dtag "row" [] $ (box ent ++ description ent)
      box ent = if isBool ent
                then checkbox ent
                else textbox ent
      textbox ent = stag "textbox" [("id",name ent),("value",key ent)]
      checkbox ent = stag "checkbox" [("id",name ent),("checked",key ent)]
      description ent = stag "description" [("value",desc ent)]


----------------------------------------------------------------
-- getter

name  (a, b, c, d, e, f) = a
grp   (a, b, c, d, e, f) = b
key   (a, b, c, d, e, f) = c
body  (a, b, c, d, e, f) = d
desc  (a, b, c, d, e, f) = e
dtype (a, b, c, d, e, f) = f

----------------------------------------------------------------

parseYml cs = case parse yml "" cs of
                Right lst -> lst

yml = many block

eol = char '\n'

block = do separator
           vals <- many keyval
           return $ lst2tuple vals
    where
      lst2tuple [a, b, c, d, e, f] = (a, b, c, d, e, f)

separator = do char '-'
               eol
               return ()

keyval = do many1 letter
            char ':'
            char ' '
            val <- many (noneOf "\n")
            eol
            return val
