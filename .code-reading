
****************
这个东西实际上是external clock的pinmux

    /home/bhj/src/rayzerlink-pad/hardware/tegra/core/drivers/nvrm/nvrmkernel/core/ap15/ap15rm_pinmux_tables.c:794:     &g_Ap15MuxCdev[0],
        /*  Array of all the controller types in the system, pointing to the array of
         *  instances of each controller.  Indexed using the NvRmIoModule value.
         */
        static const NvU32** g_Ap15MuxControllers[] = {
            ...
    =>      &g_Ap15MuxCdev[0],

****************
这个函数就是 pfnGetExtClockFreq 是怎么实现的，根据ap的版本不同有可能会调用不同的版本。

    /home/bhj/src/rayzerlink-pad/hardware/tegra/core/drivers/nvrm/nvrmkernel/core/common/nvrm_pinmux.c:136:         NvRmPrivAp15GetExternalClockSourceFreq,
        static NvPinmuxPrivMethods* NvRmPrivGetPinmuxMethods(NvRmDeviceHandle hDevice)
        {
            ...
            {
                ...
    =>          NvRmPrivAp15GetExternalClockSourceFreq,

****************

    /home/bhj/src/android-nv-froyo/hardware/tegra/core/utils/nvos/aos/aos_semihost.h:44:     void (*SemiDebugString)( const char *msg );
        /**
         * AOS supports several file i/o (semihosting) implementations.
         */
        typedef struct NvAosSemihostRec
        {
            ...
    =>      void (*SemiDebugString)( const char *msg );

****************

    /home/bhj/src/android-nv-froyo/frameworks/base/include/ui/KeycodeLabels.h:28:     { "HOME", 3 },
        static const KeycodeLabel KEYCODES[] = {
            ...
    =>      { "HOME", 3 },

****************

    /usr/share/pyshared/html2text.py:207:     def handle_tag(self, tag, attrs, start):
        class _html2text(sgmllib.SGMLParser):
            ...
    =>      def handle_tag(self, tag, attrs, start):

****************

    /usr/share/pyshared/html2text.py:270:                     if a:
        class _html2text(sgmllib.SGMLParser):
            ...
            def handle_tag(self, tag, attrs, start):
                ...
                if tag == "a":
                    ...
                    else:
                        if self.astack:
                            ...
    =>                      if a:

****************
这个地方应该是nv里配置哪个uart使用相关的代码。

    /home/bhj/src/android-byd/hardware/tegra/core/utils/nvos/aos/nvap/aos_uart.c:76:         TRISTATE_UART(B,UAA);
        static NvError aos_EnableUartA(NvU32 configuration)
        {
            ...
            case NvOdmUartPinMap_Config1:
    =>          TRISTATE_UART(B,UAA);

****************
这段代码很奇怪，(0?x)在C语言里根本不合法呀，到底是什么意思呢？
但是仔细看了一下，原来如果x也是一个宏的话，比如18:17，那么就又有意义了。

    /home/bhj/src/android-byd/hardware/tegra/core/include/nvrm_drf.h:55: #define NV_FIELD_SHIFT(x)       ((0?x)%32)
        /*
         * The NV_FIELD_* macros are helper macros for the public NV_DRF_* macros.
         */
        #define NV_FIELD_LOWBIT(x)      (0?x)
        #define NV_FIELD_HIGHBIT(x)     (1?x)
        ...
    =>  #define NV_FIELD_SHIFT(x)       ((0?x)%32)

****************
这个临时文件是通过gcc -E用了上面的这个.h文件的一个.c文件出来的，APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE的定义用gtags都搜不到，但是用grep的话可以看见，它的定义如下：
#define APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE                        18:18

    ooo:2025:         TristateReg = NvRead32((void *)(0x70000000 + APB_MISC_PP_TRISTATE_REG_B_0)); TristateReg = (((TristateReg) & ~((0xFFFFFFFFUL>>(31-((1?APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE)%32)+((0?APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE)%32)))<< (((0?APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE)%32)))) | ((APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_NORMAL) << ((0?APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE)%32))); NvWrite32((void *)(0x70000000 + APB_MISC_PP_TRISTATE_REG_B_0),(TristateReg));;
        static NvError aos_EnableUartA(NvU32 configuration)
        {
            ...
            case NvOdmUartPinMap_Config1:
    =>          TristateReg = NvRead32((void *)(0x70000000 + APB_MISC_PP_TRISTATE_REG_B_0)); TristateReg = (((TristateReg) & ~((0xFFFFFFFFUL>>(31-((1?APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE)%32)+((0?APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE)%32)))<< (((0?APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE)%32)))) | ((APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_NORMAL) << ((0?APB_MISC_PP_TRISTATE_REG_B_0_Z_UAA_RANGE)%32))); NvWrite32((void *)(0x70000000 + APB_MISC_PP_TRISTATE_REG_B_0),(TristateReg));;

****************
在这里设置用哪个终端出log

    /home/bhj/src/android-byd/hardware/tegra/odm/harmony/odm_kit/query/nvodm_query.c:330:     return NvOdmDebugConsole_UartD;
        NvOdmDebugConsole
        NvOdmQueryDebugConsole(void)
        {
    =>      return NvOdmDebugConsole_UartD;

****************


    /home/bhj/src/rayzerlink-ventana/hardware/tegra/core/drivers/nvdispmgr/server/nvdispmgr.c:2322:     pOut->TotalCount = 0;
        //===========================================================================
        // NvDispMgrDisplayListModesImpl() - list the modes for a display
        //===========================================================================
        static NvError NvDispMgrDisplayListModesImpl(
                                NvDispMgr *dm,
                                NvDispMgrClient *cl,
                                NvDispMgrDisplayListModesIn  *pIn,
                                NvDispMgrDisplayListModesOut *pOut)
        {
            ...
    =>      pOut->TotalCount = 0;

****************


    /home/bhj/src/rayzerlink-ventana/hardware/tegra/core/drivers/nvdispmgr/server/nvdispmgr.c:2680:     DM_FUNC(DisplayListModes,1);       // NvDispMgrDisplayListModesImpl()
        //===========================================================================
        // NvDispMgrInitFunctionTable() - initialize pointers to each function
        //===========================================================================
        void NvDispMgrInitFunctionTable(NvDispMgr *dm)
        {
            ...
    =>      DM_FUNC(DisplayListModes,1);       // NvDispMgrDisplayListModesImpl()

****************
i2c是在这里配置的：

    /home/bhj/src/rayzerlink-ventana/hardware/tegra/core/drivers/nvrm/nvrmkernel/core/ap20/ap20rm_pinmux_tables.c:200:     CONFIG(A,G,PTA,I2C2),CONFIGEND(),
        static const NvU32 g_Ap20Mux_I2c2[] = {
            ...
    =>      CONFIG(A,G,PTA,I2C2),CONFIGEND(),

****************
pmu之外的外部电源用的是哪个gpio

    /home/bhj/src/rayzerlink-ventana/hardware/tegra/odm/ventana/odm_kit/query/subboards/nvodm_query_discovery_pm275_addresses.h:218:     { NvOdmIoModule_Gpio, 'v'-'a', 5, 0 },
        static const NvOdmIoAddress s_Vddio_Vid_En[] = {
    =>      { NvOdmIoModule_Gpio, 'v'-'a', 5, 0 },

****************
这个pmu上还有一些gpio，可以控制输出电压？

    /home/bhj/src/rayzerlink-ventana/hardware/tegra/odm/template/odm_kit/adaptations/pmu/tps6586x/nvodm_pmu_tps6586x.c:536:         Ext_TPS72012PmuSupply_LDO,
        /* FIXME: Change getVoltage/setVoltage according to your fuse */
        static const TPS6586xPmuSupplyInfo tps6586xSupplyInfoTable[] =
        {
            ...
            {
    =>          Ext_TPS72012PmuSupply_LDO,

****************
Nvidia 自带了用gpio模拟i2c的代码，回头电源代码可以用这个来试一下。

    /home/bhj/src/rayzerlink-ventana/kernel/arch/arm/mach-tegra/nvrm/io/common/nvrm_i2c.c:539:     if ((Transaction[0].Flags & NVRM_I2C_SOFTWARE_CONTROLLER) ||
        NvError NvRmI2cTransaction(
            NvRmI2cHandle hI2c,
            NvU32 I2cPinMap,
            NvU32 WaitTimeoutInMilliSeconds,
            NvU32 ClockSpeedKHz,
            NvU8 *Data,
            NvU32 DataLength,
            NvRmI2cTransactionInfo * Transaction,
            NvU32 NumOfTransactions)
        {
            ...
    =>      if ((Transaction[0].Flags & NVRM_I2C_SOFTWARE_CONTROLLER) ||
