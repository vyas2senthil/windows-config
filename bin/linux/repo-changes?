#!/bin/bash

if test $# = 0 -a ! -d .repo; then
    set -- .
fi
    

set -- $(
    for x in "$@"; do
	echo -d "$x"
    done
)

my-rfa -j 4 "$@" -- '
#{%sh%}
set -- $($REPO_INFO remote branch path)
remote=$1
branch=$2
path=$3
# function git()
# {
#     command git "$@" || 
#     {
#         echo git "$@" failed at $(pwd);
#     } 1>&2
# }
export -f git
rev=$(git rev-parse $remote/$branch)

if test $(git rev-parse HEAD) != $rev; then
    git fetch $remote refs/heads/$branch >/dev/null 2>&1 
    rev=$(git rev-parse FETCH_HEAD)
    if test $(git rev-parse HEAD) != "$rev"; then
        (
            flock -x 9;
            echo $path rev not the same;
        )
        exit

    fi
fi

if git status -s |grep -q .; then
    (
        if test -e "$(git config core.excludesfile)"; then
            exc_file=$(git config core.excludesfile)
            for file in $(git status -s | pn 2); do
                if ! grep -e "^$file\$" -q -- "$exc_file"; then
                    flock -x 9;
                    echo $path repo not clean: $file;
                    break
                fi
            done
        fi
    )
fi
#{%/sh%}
' 2>&1 9>~/.logs/repo-changes.lock | (
    cd $(lookup_file .repo/..);
    log=./out/repo-changes.log"$(echo -n $*)"
    lognow="$log-$(now)"
    tee "$lognow" 2>/dev/null
    ln -sf $(basename "$lognow") "$log" >/dev/null 2>&1
)
