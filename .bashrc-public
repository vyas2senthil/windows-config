#!/bin/bash
export PATH=~/bin/:$PATH:/home/bhj/src/android-nv-froyo/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin:/home/bhj/external/bin/linux/ext/arm-2010q1/bin:/home/bhj/external/bin/linux/ext/arm-linux-4.1.1/bin
export PROMPT_COMMAND="history -a"

if test -z "$SSH_CLIENT"; then
    HOSTNAME=`hostname`
    export PS1='\n[01;34m{ [01;31m'`whoami`'[01;34m@[01;33m'$HOSTNAME'[01;34m [01;32m'\$PWD'[01;34m }[0m\n\$'
else
    export LOCALIP=`echo $SSH_CONNECTION|awk '{print $3}'|sed -e 's/.*://'`
    export LOCALPORT=`echo $SSH_CONNECTION|awk '{print $4}'`
    export WHOAMI=`whoami`
    export REMOTEIP=`echo ${SSH_CLIENT} | awk '{print $1}'|perl -npe 's/.*://'`
    export DISPLAY=${DISPLAY:-$REMOTEIP:0.0}
    export PS1HostName=`hostname`
    export PS1='\n( \u@$PS1HostName [01;32m| \w |[0m [01;34mRemote[01;31m:[01;34mTrue[0m)\n\$'

    function edit()
    {
        if [[ $WHOAMI == root ]] && [[ -f "$1" ]]; then
            echo using root to do edit, won\'t check read permission
        else
            if ! [[ -r "$1" ]]; then
                echo Error: "$1" is not readable
                return 1
            fi
            if ! [[ -w "$1" ]]; then
                echo Warning: "$1" is not writable
            fi
        fi    

        local file=$( readlink -f "$1" )
        ~/bin/edit.pl "$file"
    }

    alias sudoedit='WHOAMI=root edit'

fi

alias rm='rm -i'
alias mkgtags='mkgtags -i -v'
alias bcd=cd_beagle
function svn-info-clip()
{
    svn info "$1" |grep '^URL:'|sed -e 's/^URL: //; s/^https/http/'|tr -d '\r\n' | putclip
}

function cd_beagle() 
{
    dest=~/tmp/for-code-reading/`pwd`
    while test ! -d "$dest"/.beagle -a "$dest" != / -a "$dest" != ""; do
        dest=${dest%/*};
    done
    if test "$dest" = / -o "$dest" = ""; then
        echo 'You have not run for-code-reading yet, please run it first!'
        return 1;
    else
        cd_ok "$dest"
        return 0
    fi
}

function cd_ok()
{
    builtin cd "$@"
    history -s cd "$PWD"
    return 0
}

function cd_record()
{
    history -s cd "`pwd`"
   (flock -x ~/.where.lock -c where&)
}

function lcd()
{
    if test $# != 1; then
        return 1
    elif test "$1" = -; then
        cd_ok -
        return 0
    elif test "$1" = .beagle; then
        cd_beagle;
        return 0;
    fi
    

    if [[ "${1:0:2}" =~ \\\\|// && `uname` = Linux ]]; then
        smbnetfs ~/smb >/dev/null 2>&1
        builtin cd ~/smb/"$(host-hosts "$1")"
        history -s cd "`pwd`"
        history -s cd "$1"
        return 0
    fi
    
    if [[ `pwd` =~ ^$HOME/smb/ ]]; then
        _ucd $1
        return $?
    fi

    local ori=$1
    local x=0
    while ! test -e "$1" >/dev/null && ((x++ < 10)); do 
        set -- ../"$1";
    done

    if ! test -e "$1" >/dev/null; then
        _ucd $ori
        return $?
    fi

    link=$(readlink -f "$1")
    if test -f "$link" && echo "${link##*.}"|grep -i '^lnk$' -q; then 
            link=`readshortcut "$link"`
    fi
    if test -d "$link"; then
        if test "$link" = "`pwd`"; then
            return 1;
        fi
        builtin cd "$link"
        cd_record
        return $?
    else
        builtin cd "$(dirname "$link")"
        cd_record
        return $?
    fi
}

function _ucd() #we go to upper dir which match the $1, for ex, cd 'ho' in /home/bhj will go to /home, 
{
    local x=0
    dir=`dirname "$(pwd)"`
    dir_basename=`basename "$dir"`
    while ! echo $dir_basename|grep -e $1 -i -q && ((x++ < 10)); do
        dir=`dirname "$dir"`
        dir_basename=`basename "$dir"`
    done
    if test x"$dir" = x/; then #obviously, we very not likely want to go to / with this complex setup
        return 1;
    fi
    builtin cd "$dir"
    cd_record
    return $?
}

function git()
{
    if test "`pwd`" = "`readlink -f ~`"
    then
        (cd ~/windows-config/; command git "$@")
    else
        command git "$@"
    fi            
}

function rbranch()
{
    repo forall . -c 'echo $REPO_RREV'
}
stty -ixon -ixoff >/dev/null 2>&1

